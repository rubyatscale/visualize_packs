# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `parse_packwerk` gem.
# Please instead update this file by running `bin/tapioca gem parse_packwerk`.

# source://parse_packwerk-0.14.0/lib/parse_packwerk/constants.rb:3
module ParsePackwerk
  class << self
    # source://parse_packwerk-0.14.0/lib/parse_packwerk.rb:28
    sig { returns(T::Array[::ParsePackwerk::Package]) }
    def all; end

    # source://parse_packwerk-0.14.0/lib/parse_packwerk.rb:112
    sig { void }
    def bust_cache!; end

    # source://parse_packwerk-0.14.0/lib/parse_packwerk.rb:33
    sig { params(name: ::String).returns(T.nilable(::ParsePackwerk::Package)) }
    def find(name); end

    # source://parse_packwerk-0.14.0/lib/parse_packwerk.rb:43
    sig { params(file_path: T.any(::Pathname, ::String)).returns(::ParsePackwerk::Package) }
    def package_from_path(file_path); end

    # source://parse_packwerk-0.14.0/lib/parse_packwerk.rb:54
    sig { params(package: ::ParsePackwerk::Package).void }
    def write_package_yml!(package); end

    # source://parse_packwerk-0.14.0/lib/parse_packwerk.rb:38
    sig { returns(::ParsePackwerk::Configuration) }
    def yml; end

    private

    # We memoize packages_by_name for fast lookup.
    # Since Graph is an immutable value object, we can create indexes and general caching mechanisms safely.
    #
    # source://parse_packwerk-0.14.0/lib/parse_packwerk.rb:100
    sig { returns(T::Hash[::String, ::ParsePackwerk::Package]) }
    def packages_by_name; end
  end
end

# source://parse_packwerk-0.14.0/lib/parse_packwerk/configuration.rb:4
class ParsePackwerk::Configuration < ::T::Struct
  const :exclude, T::Array[::String]
  const :package_paths, T::Array[::String]

  class << self
    # source://parse_packwerk-0.14.0/lib/parse_packwerk/configuration.rb:28
    sig { params(config_hash: T::Hash[T.untyped, T.untyped]).returns(T::Array[::String]) }
    def excludes(config_hash); end

    # source://parse_packwerk-0.14.0/lib/parse_packwerk/configuration.rb:11
    sig { returns(::ParsePackwerk::Configuration) }
    def fetch; end

    # source://sorbet-runtime-0.5.10323/lib/types/struct.rb:13
    def inherited(s); end

    # source://parse_packwerk-0.14.0/lib/parse_packwerk/configuration.rb:40
    sig { params(config_hash: T::Hash[T.untyped, T.untyped]).returns(T::Array[::String]) }
    def package_paths(config_hash); end
  end
end

# source://parse_packwerk-0.14.0/lib/parse_packwerk/constants.rb:20
ParsePackwerk::DEFAULT_EXCLUDE_GLOBS = T.let(T.unsafe(nil), Array)

# source://parse_packwerk-0.14.0/lib/parse_packwerk/constants.rb:21
ParsePackwerk::DEFAULT_PACKAGE_PATHS = T.let(T.unsafe(nil), Array)

# source://parse_packwerk-0.14.0/lib/parse_packwerk/constants.rb:22
ParsePackwerk::DEFAULT_PUBLIC_PATH = T.let(T.unsafe(nil), String)

# source://parse_packwerk-0.14.0/lib/parse_packwerk/constants.rb:12
ParsePackwerk::DEPENDENCIES = T.let(T.unsafe(nil), String)

# source://parse_packwerk-0.14.0/lib/parse_packwerk/constants.rb:7
ParsePackwerk::DEPRECATED_REFERENCES_YML_NAME = T.let(T.unsafe(nil), String)

# source://parse_packwerk-0.14.0/lib/parse_packwerk/deprecated_references.rb:4
class ParsePackwerk::DeprecatedReferences < ::T::Struct
  const :pathname, ::Pathname
  const :violations, T::Array[::ParsePackwerk::Violation]

  class << self
    # source://parse_packwerk-0.14.0/lib/parse_packwerk/deprecated_references.rb:11
    sig { params(package: ::ParsePackwerk::Package).returns(::ParsePackwerk::DeprecatedReferences) }
    def for(package); end

    # source://parse_packwerk-0.14.0/lib/parse_packwerk/deprecated_references.rb:17
    sig { params(pathname: ::Pathname).returns(::ParsePackwerk::DeprecatedReferences) }
    def from(pathname); end

    # source://sorbet-runtime-0.5.10323/lib/types/struct.rb:13
    def inherited(s); end
  end
end

# source://parse_packwerk-0.14.0/lib/parse_packwerk/constants.rb:8
ParsePackwerk::ENFORCE_DEPENDENCIES = T.let(T.unsafe(nil), String)

# source://parse_packwerk-0.14.0/lib/parse_packwerk/constants.rb:9
ParsePackwerk::ENFORCE_PRIVACY = T.let(T.unsafe(nil), String)

# source://parse_packwerk-0.14.0/lib/parse_packwerk/constants.rb:11
ParsePackwerk::METADATA = T.let(T.unsafe(nil), String)

# Since this metadata is unstructured YAML, it could be any type. We leave it to clients of `ParsePackwerk::Package`
# to add types based on their known usage of metadata.
#
# source://parse_packwerk-0.14.0/lib/parse_packwerk/constants.rb:16
ParsePackwerk::MetadataYmlType = T.type_alias { T::Hash[T.untyped, T.untyped] }

# source://parse_packwerk-0.14.0/lib/parse_packwerk.rb:14
class ParsePackwerk::MissingConfiguration < ::StandardError
  # source://parse_packwerk-0.14.0/lib/parse_packwerk.rb:18
  sig { params(packwerk_file_name: ::Pathname).void }
  def initialize(packwerk_file_name); end
end

# source://parse_packwerk-0.14.0/lib/parse_packwerk/constants.rb:5
ParsePackwerk::PACKAGE_YML_NAME = T.let(T.unsafe(nil), String)

# source://parse_packwerk-0.14.0/lib/parse_packwerk/constants.rb:6
ParsePackwerk::PACKWERK_YML_NAME = T.let(T.unsafe(nil), String)

# source://parse_packwerk-0.14.0/lib/parse_packwerk/constants.rb:10
ParsePackwerk::PUBLIC_PATH = T.let(T.unsafe(nil), String)

# source://parse_packwerk-0.14.0/lib/parse_packwerk/package.rb:4
class ParsePackwerk::Package < ::T::Struct
  const :dependencies, T::Array[::String]
  const :enforce_dependencies, T::Boolean
  const :enforce_privacy, T::Boolean
  const :metadata, T::Hash[T.untyped, T.untyped]
  const :name, ::String
  const :public_path, ::String, default: T.unsafe(nil)

  # source://parse_packwerk-0.14.0/lib/parse_packwerk/package.rb:35
  sig { returns(::Pathname) }
  def directory; end

  # source://parse_packwerk-0.14.0/lib/parse_packwerk/package.rb:45
  sig { returns(T::Boolean) }
  def enforces_dependencies?; end

  # source://parse_packwerk-0.14.0/lib/parse_packwerk/package.rb:50
  sig { returns(T::Boolean) }
  def enforces_privacy?; end

  # source://parse_packwerk-0.14.0/lib/parse_packwerk/package.rb:40
  sig { returns(::Pathname) }
  def public_directory; end

  # source://parse_packwerk-0.14.0/lib/parse_packwerk/package.rb:55
  sig { returns(T::Array[::ParsePackwerk::Violation]) }
  def violations; end

  # source://parse_packwerk-0.14.0/lib/parse_packwerk/package.rb:30
  sig { returns(::Pathname) }
  def yml; end

  class << self
    # source://parse_packwerk-0.14.0/lib/parse_packwerk/package.rb:15
    sig { params(pathname: ::Pathname).returns(::ParsePackwerk::Package) }
    def from(pathname); end

    # source://sorbet-runtime-0.5.10323/lib/types/struct.rb:13
    def inherited(s); end
  end
end

# source://parse_packwerk-0.14.0/lib/parse_packwerk/package_set.rb:8
class ParsePackwerk::PackageSet
  class << self
    # source://parse_packwerk-0.14.0/lib/parse_packwerk/package_set.rb:12
    sig do
      params(
        package_pathspec: T::Array[::String],
        exclude_pathspec: T::Array[::String]
      ).returns(T::Array[::ParsePackwerk::Package])
    end
    def from(package_pathspec:, exclude_pathspec:); end

    private

    # source://parse_packwerk-0.14.0/lib/parse_packwerk/package_set.rb:28
    sig { params(globs: T::Array[::String], path: ::Pathname).returns(T::Boolean) }
    def exclude_path?(globs, path); end
  end
end

# source://parse_packwerk-0.14.0/lib/parse_packwerk/constants.rb:4
ParsePackwerk::ROOT_PACKAGE_NAME = T.let(T.unsafe(nil), String)

# source://parse_packwerk-0.14.0/lib/parse_packwerk/violation.rb:4
class ParsePackwerk::Violation < ::T::Struct
  const :class_name, ::String
  const :files, T::Array[::String]
  const :to_package_name, ::String
  const :type, ::String

  # source://parse_packwerk-0.14.0/lib/parse_packwerk/violation.rb:13
  sig { returns(T::Boolean) }
  def dependency?; end

  # source://parse_packwerk-0.14.0/lib/parse_packwerk/violation.rb:18
  sig { returns(T::Boolean) }
  def privacy?; end

  class << self
    # source://sorbet-runtime-0.5.10323/lib/types/struct.rb:13
    def inherited(s); end
  end
end
