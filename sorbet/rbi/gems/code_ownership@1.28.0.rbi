# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `code_ownership` gem.
# Please instead update this file by running `bin/tapioca gem code_ownership`.

module CodeOwnership
  extend ::CodeOwnership

  requires_ancestor { Kernel }

  # Given a backtrace from either `Exception#backtrace` or `caller`, find the
  # first line that corresponds to a file with assigned ownership
  sig do
    params(
      backtrace: T.nilable(T::Array[::String]),
      excluded_teams: T::Array[::CodeTeams::Team]
    ).returns(T.nilable(::CodeTeams::Team))
  end
  def for_backtrace(backtrace, excluded_teams: T.unsafe(nil)); end

  sig { params(klass: T.nilable(T.any(::Class, ::Module))).returns(T.nilable(::CodeTeams::Team)) }
  def for_class(klass); end

  sig { params(file: ::String).returns(T.nilable(::CodeTeams::Team)) }
  def for_file(file); end

  sig { params(package: ::ParsePackwerk::Package).returns(T.nilable(::CodeTeams::Team)) }
  def for_package(package); end

  sig { params(files: T::Array[::String], autocorrect: T::Boolean, stage_changes: T::Boolean).void }
  def validate!(files: T.unsafe(nil), autocorrect: T.unsafe(nil), stage_changes: T.unsafe(nil)); end

  class << self
    # Generally, you should not ever need to do this, because once your ruby process loads, cached content should not change.
    # Namely, the set of files, packages, and directories which are tracked for ownership should not change.
    # The primary reason this is helpful is for clients of CodeOwnership who want to test their code, and each test context
    # has different ownership and tracked files.
    sig { void }
    def bust_caches!; end

    sig { params(filename: ::String).void }
    def remove_file_annotation!(filename); end
  end
end

class CodeOwnership::Cli
  class << self
    # For now, this just returns team ownership
    # Later, this could also return code ownership errors about that file.
    def for_file(argv); end

    def run!(argv); end

    private

    def validate!(argv); end
  end
end

class CodeOwnership::InvalidCodeOwnershipConfigurationError < ::StandardError; end

module CodeOwnership::Private
  class << self
    sig { void }
    def bust_caches!; end

    sig { returns(::CodeOwnership::Private::Configuration) }
    def configuration; end

    sig { returns(::CodeOwnership::Private::OwnershipMappers::FileAnnotations) }
    def file_annotations_mapper; end

    sig { params(files: T::Array[::String]).returns(T::Hash[::String, T::Array[::String]]) }
    def files_by_mapper(files); end

    sig { params(team_name: ::String, location_of_reference: ::String).returns(::CodeTeams::Team) }
    def find_team!(team_name, location_of_reference); end

    sig { returns(T::Array[::CodeOwnership::Private::OwnershipMappers::Interface]) }
    def mappers; end

    # Returns a string version of the relative path to a Rails constant,
    # or nil if it can't find something
    sig { params(klass: T.nilable(T.any(::Class, ::Module))).returns(T.nilable(::String)) }
    def path_from_klass(klass); end

    # The output of this function is string pathnames relative to the root.
    sig { returns(T::Array[::String]) }
    def tracked_files; end

    sig { params(files: T::Array[::String], autocorrect: T::Boolean, stage_changes: T::Boolean).void }
    def validate!(files:, autocorrect: T.unsafe(nil), stage_changes: T.unsafe(nil)); end
  end
end

class CodeOwnership::Private::Configuration < ::T::Struct
  const :js_package_paths, T::Array[::String]
  const :owned_globs, T::Array[::String]
  const :skip_codeowners_validation, T::Boolean
  const :unowned_globs, T::Array[::String]

  class << self
    sig { returns(::CodeOwnership::Private::Configuration) }
    def fetch; end

    def inherited(s); end

    sig { params(config_hash: T::Hash[T.untyped, T.untyped]).returns(T::Array[::String]) }
    def js_package_paths(config_hash); end
  end
end

CodeOwnership::Private::Configuration::DEFAULT_JS_PACKAGE_PATHS = T.let(T.unsafe(nil), Array)
module CodeOwnership::Private::OwnershipMappers; end

# Calculate, cache, and return a mapping of file names (relative to the root
# of the repository) to team name.
#
# Example:
#
#   {
#     'app/models/company.rb' => Team.find('Setup & Onboarding'),
#     ...
#   }
class CodeOwnership::Private::OwnershipMappers::FileAnnotations
  include ::CodeOwnership::Private::OwnershipMappers::Interface

  sig { override.void }
  def bust_caches!; end

  sig { override.returns(T::Hash[::String, T.nilable(::CodeTeams::Team)]) }
  def codeowners_lines_to_owners; end

  sig { override.returns(::String) }
  def description; end

  sig { params(filename: ::String).returns(T.nilable(::CodeTeams::Team)) }
  def file_annotation_based_owner(filename); end

  sig { override.params(file: ::String).returns(T.nilable(::CodeTeams::Team)) }
  def map_file_to_owner(file); end

  sig { override.params(files: T::Array[::String]).returns(T::Hash[::String, T.nilable(::CodeTeams::Team)]) }
  def map_files_to_owners(files); end

  sig { params(filename: ::String).void }
  def remove_file_annotation!(filename); end
end

CodeOwnership::Private::OwnershipMappers::FileAnnotations::TEAM_PATTERN = T.let(T.unsafe(nil), Regexp)

# @abstract Subclasses must implement the `abstract` methods below.
module CodeOwnership::Private::OwnershipMappers::Interface
  interface!

  # @abstract
  sig { abstract.void }
  def bust_caches!; end

  # @abstract
  sig { abstract.returns(T::Hash[::String, T.nilable(::CodeTeams::Team)]) }
  def codeowners_lines_to_owners; end

  # @abstract
  sig { abstract.returns(::String) }
  def description; end

  # This should be fast when run with ONE file
  #
  # @abstract
  sig { abstract.params(file: ::String).returns(T.nilable(::CodeTeams::Team)) }
  def map_file_to_owner(file); end

  # This should be fast when run with MANY files
  #
  # @abstract
  sig { abstract.params(files: T::Array[::String]).returns(T::Hash[::String, T.nilable(::CodeTeams::Team)]) }
  def map_files_to_owners(files); end
end

class CodeOwnership::Private::OwnershipMappers::JsPackageOwnership
  include ::CodeOwnership::Private::OwnershipMappers::Interface

  sig { override.void }
  def bust_caches!; end

  # Package ownership ignores the passed in files when generating code owners lines.
  # This is because Package ownership knows that the fastest way to find code owners for package based ownership
  # is to simply iterate over the packages and grab the owner, rather than iterating over each file just to get what package it is in
  # In theory this means that we may generate code owners lines that cover files that are not in the passed in argument,
  # but in practice this is not of consequence because in reality we never really want to generate code owners for only a
  # subset of files, but rather we want code ownership for all files.
  sig { override.returns(T::Hash[::String, T.nilable(::CodeTeams::Team)]) }
  def codeowners_lines_to_owners; end

  sig { override.returns(::String) }
  def description; end

  sig { override.params(file: ::String).returns(T.nilable(::CodeTeams::Team)) }
  def map_file_to_owner(file); end

  sig { override.params(files: T::Array[::String]).returns(T::Hash[::String, T.nilable(::CodeTeams::Team)]) }
  def map_files_to_owners(files); end

  sig { params(package: ::CodeOwnership::Private::ParseJsPackages::Package).returns(T.nilable(::CodeTeams::Team)) }
  def owner_for_package(package); end

  private

  # takes a file and finds the relevant `package.json` file by walking up the directory
  # structure. Example, given `packages/a/b/c.rb`, this looks for `packages/a/b/package.json`, `packages/a/package.json`,
  # `packages/package.json`, and `package.json` in that order, stopping at the first file to actually exist.
  # We do additional caching so that we don't have to check for file existence every time
  sig { params(file: ::String).returns(T.nilable(::CodeOwnership::Private::ParseJsPackages::Package)) }
  def map_file_to_relevant_package(file); end
end

class CodeOwnership::Private::OwnershipMappers::PackageOwnership
  include ::CodeOwnership::Private::OwnershipMappers::Interface

  sig { override.void }
  def bust_caches!; end

  # Package ownership ignores the passed in files when generating code owners lines.
  # This is because Package ownership knows that the fastest way to find code owners for package based ownership
  # is to simply iterate over the packages and grab the owner, rather than iterating over each file just to get what package it is in
  # In theory this means that we may generate code owners lines that cover files that are not in the passed in argument,
  # but in practice this is not of consequence because in reality we never really want to generate code owners for only a
  # subset of files, but rather we want code ownership for all files.
  sig { override.returns(T::Hash[::String, T.nilable(::CodeTeams::Team)]) }
  def codeowners_lines_to_owners; end

  sig { override.returns(::String) }
  def description; end

  sig { override.params(file: ::String).returns(T.nilable(::CodeTeams::Team)) }
  def map_file_to_owner(file); end

  sig { override.params(files: T::Array[::String]).returns(T::Hash[::String, T.nilable(::CodeTeams::Team)]) }
  def map_files_to_owners(files); end

  sig { params(package: ::ParsePackwerk::Package).returns(T.nilable(::CodeTeams::Team)) }
  def owner_for_package(package); end

  private

  # takes a file and finds the relevant `package.yml` file by walking up the directory
  # structure. Example, given `packs/a/b/c.rb`, this looks for `packs/a/b/package.yml`, `packs/a/package.yml`,
  # `packs/package.yml`, and `package.yml` in that order, stopping at the first file to actually exist.
  # We do additional caching so that we don't have to check for file existence every time
  sig { params(file: ::String).returns(T.nilable(::ParsePackwerk::Package)) }
  def map_file_to_relevant_package(file); end
end

class CodeOwnership::Private::OwnershipMappers::TeamGlobs
  include ::CodeOwnership::Private::OwnershipMappers::Interface

  sig { override.void }
  def bust_caches!; end

  sig { override.returns(T::Hash[::String, T.nilable(::CodeTeams::Team)]) }
  def codeowners_lines_to_owners; end

  sig { override.returns(::String) }
  def description; end

  sig { override.params(file: ::String).returns(T.nilable(::CodeTeams::Team)) }
  def map_file_to_owner(file); end

  sig { override.params(files: T::Array[::String]).returns(T::Hash[::String, T.nilable(::CodeTeams::Team)]) }
  def map_files_to_owners(files); end
end

# Modeled off of ParsePackwerk
module CodeOwnership::Private::ParseJsPackages
  class << self
    sig { returns(T::Array[::CodeOwnership::Private::ParseJsPackages::Package]) }
    def all; end
  end
end

CodeOwnership::Private::ParseJsPackages::METADATA = T.let(T.unsafe(nil), String)
CodeOwnership::Private::ParseJsPackages::PACKAGE_JSON_NAME = T.let(T.unsafe(nil), String)

class CodeOwnership::Private::ParseJsPackages::Package < ::T::Struct
  const :metadata, T::Hash[::String, T.untyped]
  const :name, ::String

  sig { returns(::Pathname) }
  def directory; end

  class << self
    sig { params(pathname: ::Pathname).returns(::CodeOwnership::Private::ParseJsPackages::Package) }
    def from(pathname); end

    def inherited(s); end
  end
end

CodeOwnership::Private::ParseJsPackages::ROOT_PACKAGE_NAME = T.let(T.unsafe(nil), String)
module CodeOwnership::Private::TeamPlugins; end

class CodeOwnership::Private::TeamPlugins::Github < ::CodeTeams::Plugin
  sig { returns(::CodeOwnership::Private::TeamPlugins::Github::GithubStruct) }
  def github; end
end

class CodeOwnership::Private::TeamPlugins::Github::GithubStruct < ::Struct
  # Returns the value of attribute do_not_add_to_codeowners_file
  #
  # @return [Object] the current value of do_not_add_to_codeowners_file
  def do_not_add_to_codeowners_file; end

  # Sets the attribute do_not_add_to_codeowners_file
  #
  # @param value [Object] the value to set the attribute do_not_add_to_codeowners_file to.
  # @return [Object] the newly set value
  def do_not_add_to_codeowners_file=(_); end

  # Returns the value of attribute team
  #
  # @return [Object] the current value of team
  def team; end

  # Sets the attribute team
  #
  # @param value [Object] the value to set the attribute team to.
  # @return [Object] the newly set value
  def team=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class CodeOwnership::Private::TeamPlugins::Ownership < ::CodeTeams::Plugin
  sig { returns(T::Array[::String]) }
  def owned_globs; end
end

module CodeOwnership::Private::Validations; end

class CodeOwnership::Private::Validations::FilesHaveOwners
  include ::CodeOwnership::Private::Validations::Interface

  sig do
    override
      .params(
        files: T::Array[::String],
        autocorrect: T::Boolean,
        stage_changes: T::Boolean
      ).returns(T::Array[::String])
  end
  def validation_errors(files:, autocorrect: T.unsafe(nil), stage_changes: T.unsafe(nil)); end
end

class CodeOwnership::Private::Validations::FilesHaveUniqueOwners
  include ::CodeOwnership::Private::Validations::Interface

  sig do
    override
      .params(
        files: T::Array[::String],
        autocorrect: T::Boolean,
        stage_changes: T::Boolean
      ).returns(T::Array[::String])
  end
  def validation_errors(files:, autocorrect: T.unsafe(nil), stage_changes: T.unsafe(nil)); end
end

class CodeOwnership::Private::Validations::GithubCodeownersUpToDate
  include ::CodeOwnership::Private::Validations::Interface

  sig do
    override
      .params(
        files: T::Array[::String],
        autocorrect: T::Boolean,
        stage_changes: T::Boolean
      ).returns(T::Array[::String])
  end
  def validation_errors(files:, autocorrect: T.unsafe(nil), stage_changes: T.unsafe(nil)); end

  private

  # Generate the contents of a CODEOWNERS file that GitHub can use to
  # automatically assign reviewers
  # https://help.github.com/articles/about-codeowners/
  sig { returns(T::Array[::String]) }
  def codeowners_file_lines; end
end

# @abstract Subclasses must implement the `abstract` methods below.
module CodeOwnership::Private::Validations::Interface
  interface!

  # @abstract
  sig do
    abstract
      .params(
        files: T::Array[::String],
        autocorrect: T::Boolean,
        stage_changes: T::Boolean
      ).returns(T::Array[::String])
  end
  def validation_errors(files:, autocorrect: T.unsafe(nil), stage_changes: T.unsafe(nil)); end
end
