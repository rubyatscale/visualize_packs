# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `ruby-graphviz` gem.
# Please instead update this file by running `bin/tapioca gem ruby-graphviz`.

::RUBY19 = T.let(T.unsafe(nil), TrueClass)
class AttributeException < ::RuntimeError; end
class BoolException < ::RuntimeError; end
class ColorException < ::RuntimeError; end

class Dot2Ruby
  include ::GraphViz::Utils

  # @return [Dot2Ruby] a new instance of Dot2Ruby
  def initialize(xGVPath, xOutFile, xOutFormat = T.unsafe(nil)); end

  def eval(xFile); end
  def eval_string(data); end
  def run(xFile); end
end

class DoubleException < ::RuntimeError; end

# Constants for ruby-graphviz
#
# GraphViz::Constants::FORMATS: the possible output formats
#   "bmp", "canon", "dot", "xdot", "cmap", "dia", "eps",
#   "fig", "gd", "gd2", "gif", "gtk", "hpgl", "ico", "imap",
#   "cmapx", "imap_np", "cmapx_np", "ismap", "jpeg", "jpg",
#   "jpe", "mif", "mp", "pcl", "pdf", "pic", "plain",
#   "plain-ext", "png", "ps", "ps2", "svg", "svgz", "tga",
#   "tiff", "tif", "vml", "vmlz", "vrml", "vtx", "wbmp",
#   "xlib", "none"
#
# GraphViz::Constants::PROGRAMS: The possible programs
#   "dot", "neato", "twopi", "fdp", "circo"
#
# GraphViz::Constants::GRAPHTYPE The possible types of graph
#   "digraph", "graph"
#
#
# The single letter codes used in constructors map as follows:
#   G => The root graph, with GRAPHATTRS
#   E => Edge, with EDGESATTRS
#   N => Node, with NODESATTRS
#   S => subgraph
#   C => cluster
class GraphViz
  include ::GraphViz::Constants
  include ::GraphViz::Utils

  # Create a new graph object
  #
  # Options :
  # * :output : Output format (GraphViz::Constants::FORMATS) (default : dot)
  # * :file : Output file name (default : nil)
  # * :use : Program to use (GraphViz::Constants::PROGRAMS) (default : dot)
  # * :path : Program PATH
  # * :parent : Parent graph (default : nil)
  # * :type : Graph type (GraphViz::Constants::GRAPHTYPE) (default : digraph)
  # * :errors : DOT error level (default 1)
  #   * 0 = Error + Warning
  #   * 1 = Error
  #   * 2 = none
  #
  # @return [GraphViz] a new instance of GraphViz
  # @yield [_self]
  # @yieldparam _self [GraphViz] the object that the method was called on
  def initialize(xGraphName, hOpts = T.unsafe(nil), &block); end

  # Create an edge between the current cluster and the node or cluster +oNode+
  #
  # @raise [ArgumentError]
  def -(oNode); end

  # Create an edge between the current cluster and the node or cluster +oNode+
  #
  # @raise [ArgumentError]
  def <<(oNode); end

  # Create an edge between the current cluster and the node or cluster +oNode+
  #
  # @raise [ArgumentError]
  def >(oNode); end

  # Create an edge between the current cluster and the node or cluster +oNode+
  #
  # @raise [ArgumentError]
  def >>(oNode); end

  # Get the value of the graph attribute +xAttrName+
  def [](xAttrName); end

  # Set value +xValue+ to the graph attribute +xAttrName+
  def []=(xAttrName, xValue); end

  # Add nodes and edges defined by a Hash
  def add(h); end

  def add_edge(oNodeOne, oNodeTwo, hOpts = T.unsafe(nil)); end

  # Create a new edge
  #
  # In:
  # * node_one : First node (or node list)
  # * node_two : Second Node (or node list)
  # * options : Edge attributes
  def add_edges(node_one, node_two, options = T.unsafe(nil)); end

  # Create a new graph
  #
  # In:
  # * xGraphName : Graph name
  # * hOpts : Graph attributes
  def add_graph(xGraphName = T.unsafe(nil), hOpts = T.unsafe(nil), &block); end

  def add_node(xNodeName, hOpts = T.unsafe(nil)); end

  # Create a new node
  #
  # In:
  # * xNodeName : Name of the new node
  # * hOpts : Node attributes
  #
  # Return the GraphViz::Node object created
  def add_nodes(node_name, options = T.unsafe(nil)); end

  def append_attributes_and_types(script); end

  # Return a new completed graph
  def complete; end

  # Complete the current graph
  def complete!; end

  # Return true if the graph is directed.
  #
  # @return [Boolean]
  def directed?; end

  def each_attribut(&b); end

  # Calls block once for each attribute of the graph, passing the name and value to the
  # block as a two-element array.
  def each_attribute(&b); end

  # Allow you to traverse edges
  def each_edge(&block); end

  # Allow you to traverse graphs
  def each_graph(&block); end

  # Allow you to traverse nodes
  def each_node(&block); end

  # This accessor allow you to set global edges attributes
  def edge; end

  # This accessor allow you to set global edges attributes
  def edge=(_arg0); end

  # This accessor allow you to set global edges attributes
  def edge_attrs; end

  # Get the number of edges
  def edge_count; end

  def enumerate_nodes; end

  # Returns the first node found in the entire graph, starting from the root graph
  def find_node(name); end

  # Return the edge object for the given index
  def get_edge_at_index(index); end

  # Return the graph object for the given name (or nil)
  #
  # @yield [graph]
  def get_graph(xGraphName, &block); end

  # Return the node object for the given name (or nil) in the current graph
  #
  # @yield [node]
  def get_node(xNodeName, &block); end

  # Return the node object for the given index
  def get_node_at_index(index); end

  # This accessor allow you to set global graph attributes
  def graph; end

  # This accessor allow you to set global graph attributes
  def graph=(_arg0); end

  # This accessor allow you to set global graph attributes
  def graph_attrs; end

  # Get the number of graphs
  def graph_count; end

  # @return [Boolean]
  def has_parent_graph?; end

  # Get the graph name
  def id; end

  def method_missing(idName, *args, &block); end

  # Get the graph name
  def name; end

  # This accessor allow you to set global nodes attributes
  def node; end

  # This accessor allow you to set global nodes attributes
  def node=(_arg0); end

  # This accessor allow you to set global nodes attributes
  def node_attrs; end

  # Get the number of nodes
  def node_count; end

  # Generate the graph
  #
  # Options :
  # * :output : Output format (GraphViz::Constants::FORMATS)
  # * :file : Output file name
  # * :use : Program to use (GraphViz::Constants::PROGRAMS)
  # * :path : Program PATH
  # * :<format> => <file> : <file> can be
  #   * a file name
  #   * nil, then the output will be printed to STDOUT
  #   * String, then the output will be returned as a String
  # * :errors : DOT error level (default 1)
  #   * 0 = Error + Warning
  #   * 1 = Error
  #   * 2 = none
  def output(hOpts = T.unsafe(nil)); end

  def pg; end
  def pg=(x); end

  # Return the root graph
  def root_graph; end

  # Generate the graph
  #
  # Options :
  # * :output : Output format (GraphViz::Constants::FORMATS)
  # * :file : Output file name
  # * :use : Program to use (GraphViz::Constants::PROGRAMS)
  # * :path : Program PATH
  # * :<format> => <file> : <file> can be
  #   * a file name
  #   * nil, then the output will be printed to STDOUT
  #   * String, then the output will be returned as a String
  # * :errors : DOT error level (default 1)
  #   * 0 = Error + Warning
  #   * 1 = Error
  #   * 2 = none
  def save(hOpts = T.unsafe(nil)); end

  # Return the first node found in the current graph, and it subgraphs
  def search_node(name); end

  def set_position(xType, xKey, xValue); end

  # Create a new graph
  #
  # In:
  # * xGraphName : Graph name
  # * hOpts : Graph attributes
  def subgraph(xGraphName = T.unsafe(nil), hOpts = T.unsafe(nil), &block); end

  # Create a new graph from the current subgraph
  def to_graph; end

  def to_s; end

  # Return the graph type (graph digraph)
  def type; end

  def type=(x); end

  private

  # Edge between a node and a Hash
  # Used by GraphViz#add
  def add_hash_edge(node, hash); end

  class << self
    def commonGraph(o1, o2); end

    # Change default options (:use, :path, :errors and :output)
    def default(hOpts); end

    # Create a new directed graph
    #
    # See also GraphViz::new
    def digraph(xGraphName, hOpts = T.unsafe(nil), &block); end

    # Escape a string to be acceptable as a node name in a graphviz input file
    def escape(str, opts = T.unsafe(nil)); end

    # Create a random graph.
    def generate(num_nodes, num_edges, directed = T.unsafe(nil), weight_range = T.unsafe(nil)); end

    # Create a new undirected graph
    #
    # See also GraphViz::new
    def graph(xGraphName, hOpts = T.unsafe(nil), &block); end

    def options(hOpts); end

    # Create a new graph from a GraphViz File
    #
    # Options :
    # * :output : Output format (GraphViz::Constants::FORMATS) (default : dot)
    # * :file : Output file name (default : none)
    # * :use : Program to use (GraphViz::Constants::PROGRAMS) (default : dot)
    # * :path : Program PATH
    #
    # @yield [graph]
    def parse(xFile, hOpts = T.unsafe(nil), &block); end

    # Create a new graph from a GraphViz File
    #
    # Options :
    # * :output : Output format (GraphViz::Constants::FORMATS) (default : dot)
    # * :file : Output file name (default : none)
    # * :use : Program to use (GraphViz::Constants::PROGRAMS) (default : dot)
    # * :path : Program PATH
    #
    # @yield [graph]
    def parse_string(str, hOpts = T.unsafe(nil), &block); end

    # Create a new strict directed graph
    #
    # See also GraphViz::new
    def strict_digraph(xGraphName, hOpts = T.unsafe(nil), &block); end
  end
end

class GraphViz::Attrs
  # @return [Attrs] a new instance of Attrs
  def initialize(gviz, name, attributes); end

  def [](key); end
  def []=(key, value); end

  # Returns the value of attribute data.
  def data; end

  # Sets the attribute data
  #
  # @param value the value to set the attribute data to.
  def data=(_arg0); end

  def each; end
  def to_h; end
end

module GraphViz::Constants
  class << self
    def getAttrsFor(x); end
  end
end

# Const: Edge attributes
GraphViz::Constants::EDGESATTRS = T.let(T.unsafe(nil), Hash)

# Const: Output formats
GraphViz::Constants::FORMATS = T.let(T.unsafe(nil), Array)

# E, N, G, S and C represent edges, nodes, the root graph, subgraphs and cluster subgraphs, respectively
GraphViz::Constants::GENCS_ATTRS = T.let(T.unsafe(nil), Hash)

# Const: Graph attributes
GraphViz::Constants::GRAPHSATTRS = T.let(T.unsafe(nil), Hash)

# Const: graphs type
GraphViz::Constants::GRAPHTYPE = T.let(T.unsafe(nil), Array)

# Const: Node attributes
GraphViz::Constants::NODESATTRS = T.let(T.unsafe(nil), Hash)

# Const: programs
GraphViz::Constants::PROGRAMS = T.let(T.unsafe(nil), Array)

GraphViz::Constants::RGV_VERSION = T.let(T.unsafe(nil), String)

class GraphViz::DOTScript
  extend ::Forwardable

  # @return [DOTScript] a new instance of DOTScript
  def initialize; end

  def <<(line); end
  def add_type(type, data); end
  def append(line); end
  def end_with?(*args, &block); end
  def make_subgraph(name); end
  def prepend(line); end
  def to_s; end
  def to_str; end

  private

  def append_statement(statement); end
  def assure_ends_with(str, ending = T.unsafe(nil)); end
end

class GraphViz::DOTScriptData
  # @return [DOTScriptData] a new instance of DOTScriptData
  def initialize(type = T.unsafe(nil)); end

  def <<(data); end
  def add_attribute(name, value); end
  def append(data); end

  # @return [Boolean]
  def empty?; end

  def to_s; end
  def to_str; end

  # Returns the value of attribute type.
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  def type=(_arg0); end

  private

  def determine_separator; end
end

class GraphViz::Edge
  include ::GraphViz::Constants

  # Create a new edge
  #
  # In:
  # * vNodeOne : First node (can be a GraphViz::Node or a node ID)
  # * vNodeTwo : Second node (can be a GraphViz::Node or a node ID)
  # * parent_graph : Graph
  #
  # @return [Edge] a new instance of Edge
  def initialize(vNodeOne, vNodeTwo, parent_graph); end

  def -(node); end
  def <<(node); end
  def >(node); end
  def >>(node); end

  # Set values for edge attributes or
  # get the value of the given edge attribute +attribute_name+
  def [](attribute_name); end

  # Set value +attribute_value+ to the edge attribute +attribute_name+
  def []=(attribute_name, attribute_value); end

  def each_attribut(global = T.unsafe(nil), &b); end

  # Calls block once for each attribute of the edge, passing the name and value to the
  # block as a two-element array.
  #
  # If global is set to false, the block does not receive the attributes set globally
  def each_attribute(global = T.unsafe(nil), &b); end

  # Return the node two as string (so with port if any)
  def head_node(with_port = T.unsafe(nil), escaped = T.unsafe(nil)); end

  # Return the index of the edge
  def index; end

  def index=(i); end

  # Add edge options
  # use edge.<option>=<value> or edge.<option>( <value> )
  def method_missing(idName, *args, &block); end

  # Return the node one as string (so with port if any)
  def node_one(with_port = T.unsafe(nil), escaped = T.unsafe(nil)); end

  # Return the node two as string (so with port if any)
  def node_two(with_port = T.unsafe(nil), escaped = T.unsafe(nil)); end

  def output(oGraphType); end
  def pg; end

  # Return the root graph
  def root_graph; end

  # Set edge attributes
  #
  # Example :
  #   e = graph.add_edges( ... )
  #   ...
  #   e.set { |_e|
  #     _e.color = "blue"
  #     _e.fontcolor = "red"
  #   }
  #
  # @yield [_self]
  # @yieldparam _self [GraphViz::Edge] the object that the method was called on
  def set(&b); end

  # Return the node one as string (so with port if any)
  def tail_node(with_port = T.unsafe(nil), escaped = T.unsafe(nil)); end

  private

  def getNodeNameAndPort(node); end
end

class GraphViz::Elements
  # @return [Elements] a new instance of Elements
  def initialize; end

  def [](index, type = T.unsafe(nil)); end
  def each(&b); end
  def push(obj); end
  def size_of(type); end
end

class GraphViz::Ext
  class << self
    def find(ext = T.unsafe(nil)); end
  end
end

class GraphViz::Node
  include ::GraphViz::Constants

  # Create a new node
  #
  # * node_id : ID of the node
  # * parent_graph : Graph
  #
  # @return [Node] a new instance of Node
  def initialize(node_id, parent_graph); end

  # Create an edge between the current node and the node +node+
  def -(node); end

  # Create an edge between the current node and the node +node+
  def <<(node); end

  # Create an edge between the current node and the node +node+
  def >(node); end

  # Create an edge between the current node and the node +node+
  def >>(node); end

  # Get the value of the node attribute +attribute_name+
  def [](attribute_name); end

  # Set value +attribute_value+ to the node attribute +attribute_name+
  def []=(attribute_name, attribute_value); end

  def each_attribut(global = T.unsafe(nil), &b); end

  # Calls block once for each attribute of the node, passing the name and value to the
  # block as a two-element array.
  #
  # If global is set to false, the block does not receive the attributes set globally
  def each_attribute(global = T.unsafe(nil), &b); end

  # Get the node ID
  def id; end

  # List of nodes that are incident to the given node (in a directed graph neighbors == incidents)
  def incidents; end

  # Return the node index
  def index; end

  def index=(i); end

  # Add node options
  # use node.<option>=<value> or node.<option>( <value> )
  def method_missing(idName, *args, &block); end

  # List of nodes that are directly accessible from given node (in a directed graph neighbors == incidents)
  def neighbors; end

  def output; end
  def pg; end

  # Return the root graph
  def root_graph; end

  # Set node attributes
  #
  # Example :
  #   n = graph.add_nodes( ... )
  #   ...
  #   n.set { |_n|
  #     _n.color = "blue"
  #     _n.fontcolor = "red"
  #   }
  #
  # @yield [_self]
  # @yieldparam _self [GraphViz::Node] the object that the method was called on
  def set(&b); end
end

class GraphViz::Types; end

class GraphViz::Types::ArrowType < ::GraphViz::Types::Common
  def check(data); end
  def output; end
  def to_gv; end
  def to_ruby; end
  def to_s; end
end

class GraphViz::Types::Color < ::GraphViz::Types::Common
  def check(data); end
  def output; end
  def to_gv; end
  def to_ruby; end
  def to_s; end
end

GraphViz::Types::Color::HEX_FOR_COLOR = T.let(T.unsafe(nil), Regexp)
GraphViz::Types::Color::RGBA = T.let(T.unsafe(nil), Regexp)

class GraphViz::Types::ColorList < ::GraphViz::Types::Common
  def check(data); end
  def output; end
  def to_gv; end
  def to_ruby; end
  def to_s; end
end

class GraphViz::Types::Common
  # @return [Common] a new instance of Common
  def initialize(data); end

  def output; end
  def source; end
end

class GraphViz::Types::EscString < ::GraphViz::Types::Common
  def check(data); end
  def output; end
  def to_gv; end
  def to_ruby; end
  def to_s; end
end

class GraphViz::Types::GvBool < ::GraphViz::Types::Common
  # @raise [BoolException]
  def check(data); end

  def output; end
  def to_gv; end
  def to_ruby; end
  def to_s; end
end

GraphViz::Types::GvBool::BOOL_FALSE = T.let(T.unsafe(nil), Array)
GraphViz::Types::GvBool::BOOL_TRUE = T.let(T.unsafe(nil), Array)

class GraphViz::Types::GvDouble < ::GraphViz::Types::Common
  # @raise [DoubleException]
  def check(data); end

  def output; end
  def to_f; end
  def to_gv; end
  def to_ruby; end
  def to_s; end
end

GraphViz::Types::GvDouble::FLOAT_MASK = T.let(T.unsafe(nil), Regexp)

class GraphViz::Types::HtmlString < ::GraphViz::Types::Common
  def check(data); end
  def output; end
  def to_gv; end
  def to_ruby; end
  def to_s; end
end

class GraphViz::Types::LblString < ::GraphViz::Types::Common
  def check(data); end
  def output; end
  def to_gv; end
  def to_ruby; end
  def to_s; end
end

class GraphViz::Types::Rect < ::GraphViz::Types::Common
  # @raise [RectException]
  def check(data); end

  def output; end
  def to_gv; end
  def to_ruby; end
  def to_s; end
end

GraphViz::Types::Rect::FLOAT_MASK = T.let(T.unsafe(nil), Regexp)
GraphViz::Types::Rect::RECT_FINAL_MASK = T.let(T.unsafe(nil), Regexp)

class GraphViz::Types::SplineType < ::GraphViz::Types::Common
  # @raise [SplineTypeException]
  def check(data); end

  def endp; end
  def output; end
  def point; end
  def startp; end
  def to_gv; end
  def to_s; end
  def triples; end

  private

  # @return [Boolean]
  def point?; end

  # @return [Boolean]
  def splite_type?; end
end

GraphViz::Types::SplineType::ENDP_MASK = T.let(T.unsafe(nil), Regexp)
GraphViz::Types::SplineType::FINAL_POINT_MASK = T.let(T.unsafe(nil), Regexp)
GraphViz::Types::SplineType::FINAL_SPLINE_MASK = T.let(T.unsafe(nil), Regexp)
GraphViz::Types::SplineType::FLOAT_MASK = T.let(T.unsafe(nil), Regexp)
GraphViz::Types::SplineType::POINT_MASK = T.let(T.unsafe(nil), Regexp)
GraphViz::Types::SplineType::SPLINE_MASK = T.let(T.unsafe(nil), Regexp)
GraphViz::Types::SplineType::STARTP_MASK = T.let(T.unsafe(nil), Regexp)
GraphViz::Types::SplineType::TRIPLE_MASK = T.let(T.unsafe(nil), Regexp)

module GraphViz::Utils
  def find_executable(bin, custom_paths); end
  def output_and_errors_from_command(cmd); end
  def output_from_command(cmd); end
end

class GraphViz::Utils::Colors
  # @return [Colors] a new instance of Colors
  def initialize; end

  # Returns the value of attribute a.
  def a; end

  # Returns the value of attribute b.
  def b; end

  # Returns the value of attribute g.
  def g; end

  # Returns the value of attribute h.
  def h; end

  def hsv(h, s, v); end
  def hsv_string(s = T.unsafe(nil)); end
  def hsv_to_rgb(h, s, v); end
  def name(c = T.unsafe(nil)); end

  # Returns the value of attribute r.
  def r; end

  def rgb(r, g, b, a = T.unsafe(nil)); end
  def rgb_to_hsv(r, g, b); end
  def rgba_string(c = T.unsafe(nil)); end

  # Returns the value of attribute s.
  def s; end

  # Returns the value of attribute v.
  def v; end

  class << self
    def hsv(h, s, v); end
    def hsv_to_rgb(h, s, v); end
    def name(c); end
    def rgb(r, g, b, a = T.unsafe(nil)); end
    def rgb_to_hsv(r, g, b); end
  end
end

GraphViz::Utils::Colors::COLORS = T.let(T.unsafe(nil), Hash)
GraphViz::Utils::Colors::HEX_FOR_COLOR = T.let(T.unsafe(nil), Regexp)
GraphViz::Utils::Colors::RGBA = T.let(T.unsafe(nil), Regexp)

# From : http://www.geekmade.co.uk/2008/09/ruby-tip-normalizing-hash-keys-as-symbols/
class Hash
  include ::Enumerable
  include ::JSON::Ext::Generator::GeneratorMethods::Hash

  # x = {
  #   :none => String,
  #   :png => "file.png",
  #   :svg => "file.svg"
  # }
  #
  # x.each_except( :key => [:none], :value => [/\.png$/] ) do |k, v|
  #   puts "#{k} -> #{v}"
  # end
  #
  # => svg -> file.svg
  def each_except(e, &b); end

  def symbolize_keys; end
end

class Object < ::BasicObject
  include ::Kernel
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::PP::ObjectMixin

  def to_ruby; end
end

class RectException < ::RuntimeError; end
class SplineTypeException < ::RuntimeError; end

class String
  include ::Comparable
  include ::JSON::Ext::Generator::GeneratorMethods::String
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend

  def convert_base(from, to); end

  class << self
    def random(size); end
  end
end

String::BLANK_RE = T.let(T.unsafe(nil), Regexp)
